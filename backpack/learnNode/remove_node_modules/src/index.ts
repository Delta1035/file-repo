/*
 * @Author: Delta_Zheng Delta_Zheng@wistronits.com
 * @Date: 2023-01-18 13:47:13
 * @LastEditors: Delta_Zheng Delta_Zheng@wistronits.com
 * @LastEditTime: 2023-01-19 13:33:46
 * @FilePath: \triennium\learnNode\remove_node_modules\src\index.ts
 * @Description:
 *
 */
import { exec } from "child_process";
import fs from "fs";
import path from "path";
import util from "util";
import del from "del";
import rimraf from "rimraf";
import { stderr, stdout } from "process";
const execPromise = util.promisify(exec);

const cwd = process.cwd();
const containModulePathList: string[] = [];
const rmList = ["node_modules", ".angular"];

enum isDirResponseType {
  errorPath,
  isFile,
  isDir,
  isSymbolicLink,
}

/**
 *
 * @param p 文件路径
 * @returns 0 路径不存在 1 是文件 2 是目录
 */
function isDir(p: string): isDirResponseType {
  const pStat = fs.lstatSync(p);
  if (!fs.existsSync(p)) {
    return isDirResponseType.errorPath;
  } else if (pStat.isFile()) {
    return isDirResponseType.isFile;
  } else if (pStat.isDirectory()) {
    return isDirResponseType.isDir;
  } else if (pStat.isSymbolicLink()) {
    return isDirResponseType.isSymbolicLink;
  }
  throw "isDir内部错误 :>> " + p;
}

function pushPathToContainModulePathList(p: string) {
  if (rmList.includes(path.basename(p))) {
    console.log(p);

    containModulePathList.push(p);
  }
}

function main(cwd: string) {
  if (isDir(cwd) == isDirResponseType.isDir) {
    const list = fs.readdirSync(cwd);
    pushPathToContainModulePathList(cwd);
    for (let i = 0; i < list.length; i += 1) {
      const _path = path.join(cwd, list[i]);
      if (isOnlyOne("node_modules", _path.split("\\"))) {
        continue;
      }
      main(_path);
    }
  } else if (isDir(cwd) === isDirResponseType.isFile) {
    pushPathToContainModulePathList(cwd);
  }
}

async function rmNodeModules(p: string) {
  try {
    if (p.includes(".git")) {
      const { stdout, stderr } = await exec(`rimraf ${p}`);
    } else {
      const { stdout, stderr } = await exec(`rimraf ${p}`);
    }
    console.log("remove successful :>> ", p, stdout, stderr);
  } catch (error) {
    console.log(error);
  }
}

function isOnlyOne<T>(target: string, list: T[]): boolean {
  let count = 0;
  list.forEach((part) => {});
  for (let i = 0; i < list.length; i += 1) {
    if (list[i] === target) {
      count += 1;
    }
    if (count >= 2) {
      break;
    }
  }
  return count >= 2;
}

// main(String.raw`E:\azure-i4.0`);
// E:\desktop\doc
main(String.raw`/home/delta/Desktop/delta/file-repo/backpack/learnLoopback4`);
console.log(`获取路径完毕${rmList.join(",")}`);
console.log(containModulePathList);
Promise.all(containModulePathList.map(async (p) => rmNodeModules(p)))
  .then((r) => {
    console.log(r);
  })
  .catch((err) => {
    console.log(err);
  });
