## 項目相關資料

Delta_Zheng@wistronits.com

wits.deltazheng@wistron.com

WZSCN\Wits.DeltaZheng

Windows Logon Name: Wits.DeltaZheng 

Display Name: Wits.DeltaZheng 

Password: V#y4vL%m4o

Account Name  Account Owner  New Password  
 Wits.DeltaZheng     Scott Yang   R%b9jF$f7v   

| Account Name    | Account Owner | New Password |
| --------------- | ------------- | ------------ |
| Wits.DeltaZheng | Scott Yang    | A#p5cA$g5y   |

10.50.140.4

R2100015

Z19070503  wzs616//22

Edcrfv4321 K2003N159

K2003N159/F! 1234567890

K2003N159 /F!1234567890

21112900013

Wits.BenjaminHao
M%m6gU%o6s

![image-20211021103632724](C:\Users\wh2104220\Desktop\doc\Markdown\DAMS\DAMS項目.assets\image-20211021103632724.png)

[‏2021/‏7/‏30 11:39] Arlen Shaw/WZS/Wistron:  
// export const iscmUrl = 'http://iscm-api-dev-wsd-iscm.k8s-dev.k8s.wistron.com/api'; 
// export const damsUrl = 'http://dams-api-dev-wsd-iscm.k8s-dev.k8s.wistron.com/api/';  

https://modao.cc/mind/share/32e2740d73b03163c256e1de0214a737f4968b36 

>  maven{ url 'https://maven.aliyun.com/repository/google'}
>
> maven{ url 'https://maven.aliyun.com/repository/public'}
>
> maven{ url 'https://maven.aliyun.com/repository/gradle-plugin'}
>
> maven{ url 'https://maven.aliyun.com/repository/jcenter'}

  // getPlant:'authmappings/getPlant'

````html
<!-- 过账进度-->
  <app-purge-item-content-info-progress *ngIf="ticketList.length > 0" marginTop="12px" [allQty]="allQty"
    [dataList]="ticketList">
  </app-purge-item-content-info-progress>
````

**prod单号 **

21092300010  6B

***入库单***

21061700002  

dams-modal-form-detail.component

20091900001  
20091800006  

***物料号***

搬砖百科全吹   https://zhuanlan.zhihu.com/p/351519484?utm_source=wechat_session&utm_medium=social&utm_oi=42363128905728

df261

R1801188

038.04019.0001

60.4W600.DS0 

020.F0473.0050

78.47134.1BL

21030100015

assets/icon/delete.svg

  // "iscmUrl": "http://iscm-api-dev-wsd-iscm.k8s-dev.k8s.wistron.com/api",

10.41.56.40

//  "iscmUrl": "http://10.41.56.49:3001/api",

https://meet.wistron.com/scott_yang/GD0BVY57 sprint

https://meet.wistron.com/mikael_fu/QW269S4L  每天一点半

https://gitlab.wistron.com/i4.0/iscm/iscmwebui.git



邀请签核   权限问题

https://gitlab.wistron.com/i4.0/iscm/iscm_api/-/wikis/WEB-API#緯創人員維護

https://registry.npm.taobao.org/



https://gitlab.wistron.com/i4.0/iscm/iscmapp.git 

leimei@wistronits.com leangoomeilei123

> C:\Users\wh2104220\Desktop\文档\Markdown\DAMS項目\project\iscmapp\src\app\component\organisms\dams\purge-form\purge-form.component.html

![image-20210607100337189](C:/Users/wh2104220/AppData/Roaming/Typora/typora-user-images/image-20210607100337189.png)

https://xd.adobe.com/view/d19ce399-8ff9-4a87-bd58-2f7f88891120-84cf/screen/1d2c6fc8-46a6-4f04-b691-254d2337aaf9/

######      

#### api文檔

https://gitlab.wistron.com/i4.0/iscm/dams_api/-/wikis/web_api/data-analysis.md

http://10.41.56.49:3000/api

https://www.leangoo.com 

#### 角色

> 發起人 PME
>
> 簽核人 PM   
>
> 邀請簽核人 AM
>
> 轉寄前的PM ECPIC 



"SR": "Sorting / Rework",
"IQCSR": "IQC SR",
"Purge": "Purge",
"NPD_Purge": "NPD_Purge",
"Purge_SR": "Purge_S/R",
"EC_Purge": "EC_Purge"

如果是all就传小写的sr和小写purge

- app獲取默認會簽人

  ```` 
  https://gitlab.wistron.com/i4.0/iscm/iscm_api/-/wikis/WEB-API#%E7%B7%AF%E5%89%B5%E4%BA%BA%E5%93%A1%E7%B6%AD%E8%AD%B7 
  第22个
  10.41.56.40
  ````


- 獲取信息的時候彈出加載框

  ````js
  this.alertUtils.presentLoading();
  this.alertUtils.hideLoading();
  ````

- 滾動到頂部

  ```typescript
  @viewChild(IonContent) contetn:ionContent;
  this.content.scrollTop(0);
  ```


#### 版号

- -  [**config.xml**](https://gitlab.wistron.com/i4.0/iscm/iscmapp/-/blob/master/config.xml) 

- -  [**ionic.config.json**](https://gitlab.wistron.com/i4.0/iscm/iscmapp/-/blob/master/ionic.config.json) 

#### 数据库

- 10.37.36.105 3306 iscmuser damsuser iscm_dev

21080201 

## 工时

- [DAMS/daily_meeting/任务进度追踪](javascript:void(null);) 
- [DAMS/功能测试/app打包问题处理](javascript:void(null);) 

## 周报

> completed
>
> 1. ControlRun发起页面根据ECRNo带出的数据 应该加上Reason of change/relate category 啷个栏位数据
> 2. 删除网页版GR单栏位, 因为缺少转退库单数据
> 3. 调整 MO搜索功能, 当根据工单搜索时不用选择日期段
> 4. 增加sorting/rework时用户可以修改单据信息功能
>
> ongoing
>
> 1. controlRun发起页面中affectItem在无需C/R状态 应该 给用户一个 重新CR的按钮
>
> 2. 增加单元测试



## EC_Purge

## Environment

> ``` 
> export const iscmUrl = 'http://iscm-api-dev-wsd-iscm.k8s-dev.k8s.wistron.com/api';
> export const damsUrl = 'http://dams-api-dev-wsd-iscm.k8s-dev.k8s.wistron.com/api/';
> export const eAuditUrl = 'http://eaudit-api-dev-wsd-iscm.k8s-dev.k8s.wistron.com/api';
> ```
>
> webui
>
> ``` 
> "iscmUrls": "http://iscm-api-qas.wsd-iscm.10.66.226.2.k8sdev-wks.k8s.wistron.com/api",
> "iscmUrl": "http://iscm-api-dev-wsd-iscm.k8s-dev.k8s.wistron.com/api",
> 
> "eauditUrl": "http://eaudit-api-dev-wsd-iscm.k8s-dev.k8s.wistron.com/api",
> 
> "damsUrl": "http://dams-api-dev-wsd-iscm.k8s-dev.k8s.wistron.com/api/"
> 
> ```
>
> qas
>
> ``` 
> // QAS 新
> // export const iscmUrl = 'http://wksinformu.wistronks.com/iscmqas/api';
> // export const damsUrl = 'http://wksinformu.wistronks.com/damsqas/api/';
> // export const eAuditUrl = 'http://wksinformu.wistronks.com/eauditqas/api';
> 
> ```
>
> prod
>
> ```` 
> 
> "iscmUrls": "http://iscm-api-qas.wsd-iscm.10.66.226.2.k8sdev-wks.k8s.wistron.com/api",
> "iscmUrl": "http://wksinformu.wistronks.com/iscm/api",
> 
> "eauditUrl": "http://eaudit-api-dev-wsd-iscm.k8s-dev.k8s.wistron.com/api",
> 
> "damsUrl": "http://wksinformu.wistronks.com/dams/api/"
> ````
>
> ```
> 
> // PRD 新
> // export const iscmUrl = 'http://wksinformu.wistronks.com/iscm/api';
> // export const damsUrl = 'http://wksinformu.wistronks.com/dams/api/';
> // export const eAuditUrl = 'http://wksinformu.wistronks.com/eaudit/api';
> ```
>
> ````
> "iscmUrls": "http://iscm-api-qas.wsd-iscm.10.66.226.2.k8sdev-wks.k8s.wistron.com/api",
>     "iscmUrl": "http://iscm-api-dev-wsd-iscm.k8s-dev.k8s.wistron.com/api",
> ````
>
> 

## CORS

http://wksinformu.wistronks.com/damsqas/api

1. <font color=red>第1步刚刚创建好的proxy.config.json中写入以下内容进行跨域配置：</font>

   ![image-20220301100032858](C:\Users\wh2104220\Desktop\doc\Markdown\DAMS\DAMS項目.assets\image-20220301100032858.png)

以下 的配置实现了将：[http://localhost:4200/api-weather 反向代理为：](http://localhost:4200/api-weather)[http://t.weather.sojson.com](http://t.weather.sojson.com/)

- ````
  
  {
    "/api-weather": {    //需要代理的请求: http://localhost:4200/api-weather
      "target": "http://t.weather.sojson.com",//反向代理到target，请求变成：http://t.weather.sojson.com/api-weather
      "logLevel": "debug", //打印代理过程
      "changeOrigin": true,
      "secure": false,
      "pathRewrite": {
          "^/api-weather": ""  //将/api-weather替换为空，新的请求变成：http://t.weather.sojson.com
      }
    }
   
  
  ————————————————
  版权声明：本文为CSDN博主「叶巨岩」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
  原文链接：https://blog.csdn.net/weixin_38023579/article/details/105837549
  
    // "/damsapi": {
      //     "target": "http://dams-api-dev-wsd-iscm.k8s-dev.k8s.wistron.com/",
      //     "secure": false,
      //     "logLevel": "debug",
      //     "changeOrigin": true,
      //     "pathRewrite": {
      //         "^/damsapi": ""
      //     }
      // },
      
      
      "/iscmapi": {
          "target": "http://iscm-api-dev-wsd-iscm.k8s-dev.k8s.wistron.com",
          "secure": false,
          "logLevel": "debug",
          "changeOrigin": true,
          "pathRewrite": {
              "^/iscmapi": ""
          }
      }
  ````

- 3.*配置根目录下的angular.json,这一步最重要！！网上的教程都没有

  在其中的serve.options加入配置："proxyConfig": "proxy.config.json"

  > ![image-20210806094320281](C:\Users\wh2104220\Desktop\文档\Markdown\DAMS項目\DAMS項目.assets\image-20210806094320281.png)
  
  

## Build

#### 新的打包测试流程

PCBA

FA

```
 [
    {
        id: 13,
        SRNo: "21112900013",
        MO: "1223123",
        type: "FA",
        line: [
            "HS2",
            "HS3"
        ],
        onlineTime: "2021-12-22T08:57:00.000Z",
        stages: [
            {
                stage: "3T.SPI TOP",
                reason: "hold reason22",
                status: "Hold",
                createdBy: "Wits.BenjaminHao",
                createdTime: "2021-12-03 17:38:09"
            },
            {
                stage: "4T.SPI TOP",
              reason: "release reason22",
              status: "Release",
              createdBy: "Wits.BenjaminHao",
               createdTime: "2021-12-03 17:38:09"
          }
        ]
    },
    {
        id: 15,
        SRNo: "21112900013",
        MO: "12231231",
        type: "PCBA",
        line: [
            "HS2",
            "HS3"
        ],
        onlineTime: "2021-12-22T08:57:00.000Z",
        stages: [
            {
                stage: "3T.SPI TOP",
                reason: "hold reason222",
                status: "Hold",
                createdBy: "Wits.BenjaminHao",
                createdTime: "2021-12-03 17:38:09",
                updatedBy: "Wits.BenjaminHao",
                updatedTime: "2021-12-07 10:49:38"
            },
            {
                stage: "4T.SPI TOP",
                reason: "release reason222",
                status: "Release",
                createdBy: "Wits.BenjaminHao",
                createdTime: "2021-12-03 17:38:09",
                updatedBy: "Wits.BenjaminHao",
                updatedTime: "2021-12-07 10:49:38"
            }
        ]


```



- https://iscm-app-wsd-iscm.k8sdev-wks.k8s.wistron.com/imqmApp 
- http://iscm-app-qas-service-lb.wsd-iscm.10.66.226.2.k8sdev-wks.k8s.wistron.com/ 

> 只用在开发测试情况

1. ionic cordova build android

2. installJPush 这个func  注释掉从github获取资源

3. gulp buildAndroidQas  此时会失败

4. 可能会缺少jpush包 先安装 npm i  jpush包

5. ionic cordova build android  此时会卡在100%   

   Resolve dependencies of :app:debugCompileClasspath > maven-metadata.xml

###### 替换

```

maven{ url 'https://maven.aliyun.com/repository/google'}

maven{ url 'https://maven.aliyun.com/repository/gradle-plugin'}

maven{ url 'https://maven.aliyun.com/repository/public'}

maven{ url 'https://maven.aliyun.com/repository/jcenter'}
```



#### adb

- adb devices    查看当前接入的设备
- adb shell 
- logcat | grep "Line 1"

#### CLI

1. install jpush

   > - ionic cordova plugin add jpush-phonegap-plugin --variable APP_KEY=6c28554d5d7a08888e67f2ae   //需要把jpush插件放到对应的目录
   > - npm install @jiguang-ionic/jpush -s
   > - ionic cordova plugin add https://github.com/jpush/jpush-phonegap-plugin.git --variable APP_KEY=6c28554d5d7a08888e67f2ae



>​    真机调试
>
>chrome://inspect/#devices
>
>- 如果卡在某个部分 ctrl + c  退出查看报错, 有可能需要升级ionic cli
>- 版本问题 手机本地webview  不能高于pc webview

- 将ionic cordova build android --release 产生的未签核的apk文件放到 jdk -> bin 文件夹里面  并改为 app.apk

>jarsigner -verbose -keystore spilledyear.keystore -signedjar complete.apk app.apk spilledyear.keystore
>
>// spilledyear.keystore 数字证书文件名
>
>// complete.apk  签名后产生的已签名apk
>
>//app.apk 需要签名的apk文件名
>
>
>
>```css
>jarsigner -verbose -keystore spilledyear.keystore -signedjar zmjj.apk android-release-unsigned.apk spilledyear.keystore
>
>jarsigner是工具名称 
>-verbose表示将签名过程中的详细信息打印出来，显示在dos窗口中
>-keystore spilledyear.keystore 表示签名所使用的数字证书所在位置，没有写路径表示在当前目录下
>-signedjar zmjj.apk android-release-unsigned.apk 表示给android-release-unsigned.apk文件签名，签名后的文件名称为zmjj.apk 
>spilledyear.keystore 表示证书的别名，对应于生成数字证书时-alias参数后面的名称
>```
>
>
>
>```css
>keytool -genkey -v -keystore spilledyear.keystore -alias spilledyear.keystore -keyalg RSA -validity 36500
>
>keytool是工具名称  
>-genkey意味着执行的是生成数字证书操作 
>-v表示将生成证书的详细信息打印出来，显示在dos窗口中  
>-keystore spilledyear.keystore 表示生成的数字证书的文件名为“ spilledyear.keystore”(spilledyear可以取自己的名字) 
>-alias spilledyear.keystore 表示证书的别名为“spilledyear.keystore”，当然可以不和上面的文件名一样 
>-keyalg RSA 表示生成密钥文件所采用的算法为RSA 
>-validity 36500 表示该数字证书的有效期为36500天，意味着36500天之后该证书将失效 
>```

## 任务安排模板

- 项目名\主功能模块\子模块\简要描述功能(不超过15个字)

- 12月27日-12月31日

- 郝旭阳

- 1. 工作安排:
  2.affectItem核准
  3.送出流程更新状态和步骤
  4.新增转退库逻辑

- 郑重阳

  工作安排:

  1.web上查看动态导图

  2.web上查看MO的yiled rate 以及下载 yiled rate

  3.web上查看MO的top list 以及下载 top list

  1.删除采购下po功能和输入栏位的删减。
  2.入了用户改为送出的会议信息的删除功能。
  completed
  1.follow总览页面的展示
  2.web上control run会议记录的展示页面
  
  ongoing
  
  1.会议记录下载功能
  
  2.reprocess api对接

> 12月20日-12月24日
>
> 郝旭阳
>
> 工作安排:
> 1.stage nifi 
> 2.hold mo nifi
> 3.获取stage列表
> 
>郑重阳
> 
>工作安排:
> 
>1.配合后端修改api
> 
>2.调整会议记录更新api请求参数
> 
>3.调整图片展示组件
> 
>4.增加新增FATP MO页面 以及里面的多个选择页面

>Sprint 4  11月15日到11月19日
>
>工作安排：
>
>1. 增加ControlRun发起时数据由ECRNo带出
>
>2. 关于controlRun发起时对已有的表单数据的删除和编辑功能
>
>3. 用户图片上传功能
>
>   
>
>Sprint 2  8月9日到8月13日
>
>Sprint 2  10月19日到11月1日
>
>工作安排:
>
>1. 修改通知与通知内容维护部分 通知编辑的UI
>2. 增加库房维护页面, 增加库房维护增删改查功能以及UI界面
>
>工作安排：
>
>1. 增加Sorting/Rework发起时的非必填栏位Cost center
>2. 增加Sorting/Rework总览部分手动结案功能
>3. 调整页面布局, 修改bug
>4. 参与下一个模块功能会议,讨论页面布局.
>
>8月30日到9月10日
>
>工作安排：
>
>1. 增加iqc sr 确认发起后的手动结案功能
>2. 解决jpush注册问题, 并将badge对接jpush
>3. 查找https在ios端出问题的解决办法
>4. 解决nativeHttp插件在测试过程中的问题
>5. 解决用户在使用过程的问题
>
>9月6日到9月10日
>
>工作安排：
>
>1.增加Purge SR发起时的iqc检验人栏位
>
>2.学习angular单元测试框架
>
>3.解决用户使用过程中遇到的问题,调整UI
>
>3.解决gulp打包过程遇到的问题
>
>9月22日到9月24日
>
>工作安排：
>
>5. 解决用户在使用过程的问题
>2. 解决web端purge部分供应商数据异常问题
>3. 给项目网络请求增加拦截器做一些报错处理
>4. 解决web端非必现bug
>5. 解决web端页面跳转到非当前模块
>
>目前的情况:
>
>1. 小红点这个插件在安卓上可以显示 , 对接jpush时没有生效
>
>2. http插件 在经过**ionic cordova run android -l -c**    真机调试 发现一直提示401
>
>3. angular自带的httpclient请求 在调试的时候也显示401, 但是Arlen那边收到的数据都正常. 打包成app安装后登录正常,也就是说请求没有问题, 但是没法在调试的时候收到数据.
>
>4. 通过adb 查看log 发现ionic 启动时安装jpush插件没有成功, 但是现在上限的qas和prod 版本 jpush都是正常在运行,
>
>考虑是打包方式的问题, 目前通过gulp打包 会报错.
>
>- 自动删除config.xml
>- jpush插件自动删除
>- ionic cordova platform add android 报错
>
>9-29 ~ 10.15 
>
>10月25日到10月29日
>
>工作安排：
>
>1. 库房搜索功能
>2. 库房新增功能
>3. 库房编辑功能
>4. app端controlRun发起入口页面
>5. 处理用户issue, code review
>
>`control run`
>
>3  0.5 0.5 2
>
>1. 选项内容是什么

> hi scott, 早上的报错解决了. 然后今天把库房删除api对接了, 删除功能正常.
> 但是表格显示某些情况还是有异常,需要调整, 今天下午会接着调整布局, 以及多国语文件.
>
> 下午1.30 -4.00 , 我要参加部门培训, 今天没办法参加日会了.



## Code

#### TODO

>
> 
> 收货人 郑重阳
>
> 手机号码 18062313327
>
> 所在地区 湖北武汉市洪山区花山街道 
>
> 详细地址 亿达云山湖﹣5栋2单元﹣501
>
> 保存

>1. SRNo 非必填 但是 cr中 要给后端
>2. 新增MO Hold 不用传SRNo, 增加了一个plant 必填.
>3. 

```
  expandSignList(item) {
    console.log('expandSignList', item);
    this.isExpand = !this.isExpand;
    this.signType = this.damsFormDataService.getFormTypeProcessString(item.formType);
    console.log('expandSignList', item);
    this.apiService.getPicSignInfo(item.formId, item.formType).then((res: any) => {
      console.log('getPicSignInfo', res);
      const data = res.response.data;
      this.signContent = data;
    }).then(err => {
    });

  }
```



> // 展开
>
> expandSignList(item) {
>
>  console.log('expandSignList', item);
>
>  this.isExpand = !this.isExpand;
>
>  this.signType = this.damsFormDataService.getFormTypeProcessString(item.formType);
>
>
>
>  console.log('expandSignList', item);
>
>  this.apiService.getPicSignInfo(item.formId, item.formType).then((res: any) => {
>
>   console.log('getPicSignInfo', res);
>
>   const data = res.response.data;
>
>   this.signContent = data;
>
>  }).then(err => {
>
>
>
>  });
>
> }

> ![](C:\Users\wh2104220\Desktop\doc\Markdown\DAMS\DAMS項目.assets\image-20220208110911125.png)

>1. MO: "90265664"
>2. SRNo: "21112900013"
>3. affectItemId: 151
>4. costCenter: "AKME1700"
>5. createDate: "2022-01-20T16:00:00.000Z"
>6. employeeNo: "Z19070503"
>7. fromLocation: null
>8. fromPlant: null
>9. id: 229
>10. initialPlant: "F232"
>11. keeper: "1"
>12. material: "038.04019.0001"
>13. movementType: "262"
>14. quantity: 1
>15. reasonCode: "0"
>16. status: 1
>17. ticketNo: null
>18. toLocation: "W10B"
>19. toPlant: null
>20. type: 1



>1. MO: null
>2. SRNo: "21112900013"
>3. affectItemId: 151
>4. costCenter: "AKDMS500"
>5. createDate: "2022-01-20T16:00:00.000Z"
>6. employeeNo: "Z190705031"
>7. fromLocation: "W101"
>8. fromPlant: null
>9. id: 227
>10. initialPlant: "F232"
>11. keeper: "1"
>12. material: "038.04019.0001"
>13. movementType: "311"
>14. quantity: 1
>15. reasonCode: "0"
>16. status: 2
>17. ticketNo: null
>18. toLocation: "W10A"
>19. toPlant: null
>20. type: 0

- 退库单 fromLocation 不是必填项
- keeper 不必填 三位
- 262 退库单 mo 必填



- tolocation转入仓 目的仓库 w102   

- translocation退库仓默认不退 w109

- 

- 采购下po 勾选则 可以不选会议资讯: 否则必须填写会议资讯

- 机种 projectName

- 会议主席 机种不可改

- > modalStepListI18
  >
  > modalTypeListI18
  >
  > modalParamListI18
  >
  > - receiver 
  > - signerAndRemark 
  > - formPic
  >
  > modalNotificationI18

- > "conterSign"
  >
  > "NPDPurgeInitiate":"NPD确认发起",
  >
  > "conterSign":"会签",
  >
  > "transferForm":"转库单",
  >
  > "returnForm":"退库单",

- > Hi,scott. 我今天早上增加了会议资讯部分的四个栏位, 以及AffectItem增加按钮,我有把代码提交到master, 麻烦merge一下.
  >
  > 我下午需要参加部门培训, 可能没办法参加例会了.

- >
  >
  >1. 0: "purgeNo":"Purge单号",
  >2. 4: "iqcQty":"IQC数量",
  >3. 5: "whQty":"WH数量",
  >4. 6: "pdQty":"PD数量",
  >5. 9: "forbidType":"禁用系统",
  >6. 10: "releaseType":"解禁系统"

- DAMS/coding/

- getProjectList 

  ``` 
  {
  project:"ecpurge"  //有两个forbid
  }
  ```

  

- > 1. ![image-20211028150556961](C:\Users\wh2104220\Desktop\doc\Markdown\DAMS\DAMS項目.assets\image-20211028150556961.png)
  >
  > 2. **1**: "deleteProject":"删除单据",
  >
  > 3. **2**: "preClose":"提早结案",
  >
  > 4. **3**: "cancel":"取消Purge",
  >
  > 5. **4**: "returnSign":"退库单签核",
  >
  > 6. **5**: "transferSign":"转库单签核",
  >
  > 7. **6**: "purgeRate":"Purge进度",
  >
  > 8. **7**: "qty":"填写数量完成",
  >
  > 9. 
  >
  > 10. **9**: "forbid":"禁限用",
  >
  > 11. **10**: "createTicketOrTransfer":"开表单",
  >
  > 12. **11**: "formSign":"表单签核",
  >
  > 13. **12**: "purgeWork":"Purge作业",
  >
  > 14. **13**: "fill8D":"填写8D",
  >
  > 15. **14**: "review8D":"8D审核",
  >
  > 16. 
  >
  > 17. **16**: "fillQty":"填写数量",
  >
  > 18. **17**: "meeting":"Purge会议"
  >
  > 19. "generatePurge":"触发Purge",
  >
  > 20. 
  >
  > 21. *14**: "fillPrice":"填写价格",
  >
  >     **15**: "confirmInit":"确认发起"

- > [api · Wiki · i4.0 / iSCM / DAMS_API · GitLab (wistron.com)](https://gitlab.wistron.com/i4.0/iscm/dams_api/-/wikis/web_api/api#通知维护)

- > ,
  >
  >  "paths":{
  >
  >   "exceljs":[
  >
  >    "./mode_modules/exceljs/dist/exceljs.bare.min.js"
  >
  >   ]
  >
  >  }

- getKPIInfo 

  >点击详情  =>  保存数据到localStorage

- 数据有些异常, 2rd descpription

- > 直接ionic cordova build android --release 打包出来的app没有包含jpush这个插件,
  >
  > 然后使用 gulp脚本之后 有报错 解决了报错之后卡在100% 不动了

- ![image-20210917165205588](C:\Users\wh2104220\Desktop\doc\Markdown\DAMS\DAMS項目.assets\image-20210917165205588.png)

- ![image-20210917174833697](C:\Users\wh2104220\Desktop\doc\Markdown\DAMS\DAMS項目.assets\image-20210917174833697.png)

  

- > //默认通知人
  >
  > private DAMS_PERMISSION_WEB_NOTIFIER = 25;
  >
  > //默认通知人
  >
  > private DAMS_PERMISSION_WEB_FILLSINGLE = 26;
  >
  >  //默认通知人
  >
  > private DAMS_PERMISSION_WEB_SIGNER = 27;
  >
  > 
  >
  > public damsNotifierPermission;
  >
  > public damsFillsinglePermission;
  >
  > public damsSignerPermission;
  >
  > 
  >
  > allowedCreate: false,
  >
  >   allowedDelete: false,
  >
  >   allowedRead: false,
  >
  >   allowedUpdate: false,

  


- 签核的时候发起请求, 只有buyer能够填写.

- iqc 检验人栏位

  >type: "SR_IQC",
  >
  >iqcUser 必填 [];
  >
  >

- IQCSR 发起界面的垃圾桶 flagClose:true, initator === empno √

- > ![image-20210813091701060](C:\Users\wh2104220\Desktop\doc\Markdown\DAMS\DAMS項目.assets\image-20210813091701060.png)

- sr没有默认通知人 

- ecpurge 会签按钮按不动

- **pm邀请am签核 但是被选中的料号没有发送出去,下周解决,  邀请之后就应该不能在勾选料号了,待修改**   √

- **获取不到厂区问题 需要确认 一下url问题**    √

- NumpadEnter Enter  两种情况, 待确认手机端是否能正常执行

- iqc-sr  获取动态导图 缺少type 参数.  √

- Sr => 会签之后显示按钮flagCode = true ;  loginRole == initator   √

- iqc-sr = > flagclose = true,;    判断条件有点问题, flagClose 实际值为false;

- 过账数量 quantity

> ​     // 转库单
>
> ​     if (element.type === '311') {
>
> ​      this.transferList.push(element);
>
> ​     } else if (element.type === '262') {
>
> ​      //退库单
>
> ​      this.returnList.push(element);
>
> ​     }
>
> ​     // 添加已过账列表
>
> ​     if (element.flagStock === 'Y') {
>
> ​      this.ticketList.push(element);
>
> ​     }
>
>   // 获取总用料数量
>
>   this.allQty = data.pdQty + data.whQty;

21032400030  

21011210015 

21041500020 

21061700002 sr有过账数据
21051900012  purge过账数据

pallet 入库单    totalQty

tickets 领料单



>
>
>![image-20210809173029254](C:\Users\wh2104220\Desktop\doc\Markdown\DAMS\DAMS項目.assets\image-20210809173029254.png)
>
>![image-20210809173050434](C:\Users\wh2104220\Desktop\doc\Markdown\DAMS\DAMS項目.assets\image-20210809173050434.png)





````typescript
/*
 * @Autor: Chauncey Yuan
 * @Date: 2021-07-01 13:53:38
 * @LastEditors: Chauncey Yuan
 * @LastEditTime: 2021-07-02 17:02:12
 * @Description: This is a description about this file!
 * @FilePath: \iscmapp\src\environments\environment.ts
 */
// This file can be replaced during build by using the `fileReplacements` array.
// `ng build --prod` replaces `environment.ts` with `environment.prod.ts`.
// The list of file replacements can be found in `angular.json`.

export const environment = {
    production: false,
    env: 'dev'
};

// DEV
export const iscmUrl = 'http://iscm-api-dev-wsd-iscm.k8s-dev.k8s.wistron.com/api';
export const damsUrl = 'http://dams-api-dev-wsd-iscm.k8s-dev.k8s.wistron.com/api/';
export const eAuditUrl = 'http://eaudit-api-dev-wsd-iscm.k8s-dev.k8s.wistron.com/api';

// Iris YT Hsu local Service
// export const eAuditUrl = 'http://10.38.160.167:3000/api';

// Chauncey Yuan local Service
// export const eAuditUrl = 'http://localhost:3000/api';

// Arlen local Service
// export const iscmUrl = 'http://10.41.56.40:3001/api';
// export const damsUrl = 'http://10.41.56.40:3000/api/';


// QAS 內網
// export const iscmUrl = 'http://iscm-api-qas-service-lb.wsd-iscm.10.42.226.2.k8sprd-wks.k8s.wistron.com/api';
// export const damsUrl = 'http://dams-api-qas-service-lb.wsd-iscm.10.42.226.2.k8sprd-wks.k8s.wistron.com/api/';
// export const eAuditUrl = 'http://eaudit-api-qas-service-lb.wsd-iscm.10.42.226.2.k8sprd-wks.k8s.wistron.com/api';

// QAS 外網
// export const iscmUrl = 'http://ifactory.wks.wistron.com/iscmqas/api';
// export const damsUrl = 'http://ifactory.wks.wistron.com/damsqas/api/';
// export const eAuditUrl = 'http://ifactory.wks.wistron.com/eauditqas/api';

// PRD 內網
// export const iscmUrl = 'http://iscm-api-service-lb.wsd-iscm.10.42.226.2.k8sprd-wks.k8s.wistron.com/api';
// export const damsUrl = 'http://dams-api-service-lb.wsd-iscm.10.42.226.2.k8sprd-wks.k8s.wistron.com/api/';
// export const eAuditUrl = 'http://eaudit-api-service-lb.wsd-iscm.10.42.226.2.k8sprd-wks.k8s.wistron.com/api';

// PRD 外網
// export const iscmUrl = 'http://ifactory.wks.wistron.com/iscm/api';
// export const damsUrl = 'http://ifactory.wks.wistron.com/dams/api/';
// export const eAuditUrl = 'http://ifactory.wks.wistron.com/eaudit/api';


/*
 * For easier debugging in development mode, you can import the following file
 * to ignore zone related error stack frames such as `zone.run`, `zoneDelegate.invokeTask`.
 *
 * This import should be commented out in production mode because it will have a negative impact
 * on performance if an error is thrown.
 */
  // import 'zone.js/dist/zone-error';  // Included with Angular CLI.


````







> http://dams-api-dev-wsd-iscm.k8s-dev.k8s.wistron.com/api/authmappings/getPlant
>
> http://dams-api-dev-wsd-iscm.k8s-dev.k8s.wistron.com/apiauthmappings/getPlant

[‏2021/‏8/‏6 15:16] Arlen Shaw/WZS/Wistron:  

{
 "iscmUrl" : "http://iscm-api-qas.wsd-iscm.10.66.226.2.k8sdev-wks.k8s.wistron.com/api",
 "damsUrl" : "http://dams-api-qas-service-lb.wsd-iscm.10.66.226.2.k8sdev-wks.k8s.wistron.com/api",
 "eauditUrl" :"http://eaudit-api-qas.wsd-iscm.10.66.226.2.k8sdev-wks.k8s.wistron.com/api"
 }  



- 401 弹窗密码错误

- iqc填写数量送出 √

- 发起的时候送出   item-content √

- 轉寄人 被轉寄人一定看的見 轉寄人欄位,pme, (確認)  √

- 發起之後就可以隨時刪單,code2.3 可以刪單,把自己的標籤只留pme, 看下確認發起之後能不能刪單 在總覽following狀態可以刪單  √

- sorting 默認通知人可以不填  √

- sr發起 似乎之後在following裡面, 刷新一下進到了pendding (未復現)

- 在purge發起中(sr發起) 默認填單人待做 => 在審核人員裡面直接帶入默認填單人,默認會簽人  √

- am看不見原因,需要刷新一下   => 還是有問題

- pm邀請簽核之前需要先勾選料號, 增加提示簽核勾選料號,   √

  同意簽核一定需要勾選料號,拒絕可以不選料號.    √

- 070100001 參考這筆單子,原因,mic brand code 數據需要刷新一下才能顯示出來  √

  - 發起界面變換代理人 原因顯示正常, 轉寄人顯示正常.

​	底部按钮  预览状态 preview  填单状态 fillPurge

​	PIC  审核 通知人

​	ec_purge 由 系统生成,  iqc , wh , pd 填单,

​	pd,iqc,wh 可以看到送出按钮, 

​	审核人员(pm,am)可以看见变换代理人和取消purge 按钮

​	按钮上面的 新增审核人员 将会改动为 默认填单人              

- EC_Purge发起只能有PIC发起

- 2.9  IQC、WH、PD填写，可能有多个
  2.12 角色是签核人 role===signer，职种标签 Buyer 采购填写
  2.11 Pending 发起人 EC Purge确认发起
  2.1 Pending 角色是签核人 AM签核 
  PM 签核完 进来只能看 不能操作

  2.3 
  
  - PD进来才可以填写mo ---
  - 一个pn下面几个vendor ---
  - 供应商TDK ---

#### 流程

initor===emope发起  => iqc , wh, pd   => buyer

- 当前填单人是buyer或者pm,pic,am时可以看到

  2.9  IQC、WH、PD填写，可能有多个
  2.10 角色是签核人 role===signer，职种标签 Buyer 采购填写 => 改变为2.12
  2.11 Pending 发起人 EC Purge确认发起
  2.1 Pending 角色是签核人 AM签核 
  PM 签核完 进来只能看 不能操作
  
  - PD进来才可以填写mo ---
  - 一个pn下面几个vendor ---
  - 供应商TDK ---
  
- code  2.2 锁库存，62501 单号测试

  

## Control Run

> "sendSigner":"会签人", 
> "sendNotifier":"通知人",
> "sendFiller":"填单人"
> "sendInitiator":"发起人"
>
> "plzChooseSite":"请选择地区!",
>
> "plzChooseType":"请选择类别",
>
> "searched":"搜索到",
>
> "countData":"条数据!",
>
> "countParam":"条参数",
>
> "successDelete":"成功删除"
>
> "plzChoosePlant":"请选择厂区!",
>
> "dataUpdateSuccess":"数据更新成功",
>
> "countDataUpdateSuccess":"条数据更新成功",
>
> "getDataFail":"获取数据失败",
>
> "addSuccess":"新增成功",
>
> "addFail":"新增失败",
>
> "getParamsFailPlzRetry":"获取参数失败,请重试",
>
> "plzChooseParamsTargetlocation":"请选择要添加参数的目标栏位",
>
> "addFailEmailExist":"增加失败,该邮箱信息已存在",
>
> "getNotifytypeListSuccess":"获取通知类型列表成功",
>
> "getNotifytypeListFail":"获取通知类型列表失败",
>
> "DontRepeatToAdd":"不要重复添加"

###### dashboard 入口

下面是PCBA的F232和F236提供的MO号

p5(000025981396) p6(000037234892)

下面是FATP的F232和F236提供的MO号

p5(000024541564) p6(000016815550)

assets/icon/approve.svg

assets/icon/reject.svg

1. 根据code 以及用户的职种标签 展示不同的功能按钮,

   发起时 会议主席是必填项, 其他的会议资讯可以在3.3阶段给会议主席补充完整.

2. 3. 1等待发起人确认

3. 3. 2采购更新填写po

4. 3. 3 会议主席 更新会议资讯  => 后续更新会议主席也需要会签是否参会

5. 3. 4会议参与者 会签 拒签 变换代理人

6. 3. 5所有人签核完毕等待开会

7. 3. 6填写会议记录 会议主席可以release会议记录

8. 3. 7会议主席 CR核准 

9. 3. 8原材转退

10. 总览 直接根据 follow

11. ​      // "baseHref": "imqmApp", 

---

会议主席  K2003N159/Fuchao1994 

采购确认 po之后 会议主席  来补充会议资讯

assets/icon/dams/icon-plant.svg

assets/icon/dams/down.svg

purge 拿到线别  切入线别也是这个

>     "orders": [
>         {
>             "type": 0,
>             "initialPlant": "F232",
>             "movementType": "311",
>             "employeeNo": "Z19070503",
>             "costCenter": "AKDMS500",
>             "fromLocation": "W101",
>             "toLocation": "W10A",
>             "material": "038.04019.0001",
>             "quantity": 1,
>             "keeper": "F11",
>             "reasonCode": "0"
>         },
>         {
>             "type": 1,
>             "MO": "90265664",
>             "initialPlant": "F232",
>             "movementType": "262",
>             "employeeNo": "Z19070503",
>             "costCenter": "AKME1700",
>             "toLocation": "W10B",
>             "material": "038.04019.0001",
>             "quantity": 1,
>             "keeper": "F11",
>             "reasonCode": "0"
>         }
>     ]

#### 报错提示

> {
> "MEETINGMO_CREATEMO_REPEAT_MO": "创建工单，MO已存在",
> "MEETINGMO_CUMO_UNKNOW_MO_TYPE": "未知工单类型",
> "MEETINGMO_CUMO_UNKNOW_MO_PLANT": "未知工单厂别",
> "MEETINGMO_CREATEMO_HOLD_MO": "创建工单失败",
> "MEETINGMO_UPDATEMO_HOLD_MO": "更新工单失败",
>
> WHORDER_CREATE_INFO_INCOMPLETE: 单据信息填写不完整,
>
> WHORDER_CREATE_FAILED: 创建单据失败
>
> WHORDER_REPROCESS_FAILED: reprocess单据失败
>
>   "CONTROLRUN_CREATE_AFFECTITEM": "AffectItem信息有误",
>   "CONTROLRUN_UPDATECRTOSTEP_STEPEIGHT": "请先核准完成后再送出"
>
> }



```
  const controls = this.holdStageForm.controls;
    for(let ele in controls){
      console.log('confirm',controls[ele]);
      if(controls[ele].status === "INVALID"){
       await this.alertUtils.presentAlert('請填寫完整!');
       return;
      }
    }
```



```
this.apiService.getLineList(plant) 获取线别
   const userName = JSON.parse(localStorage.getItem("userInfo")).userName;
    this.allSites = [];
    this.allPlants = [];
    this.apiService
      .getUserPlant(userName)
```

#### 组件

```
,
  {
    path: 'dams-control-run-add-meeting-content',
    loadChildren: () => import('./component/organisms/dams/dams-control-run-add-meeting-content/dams-control-run-add-meeting-content.module').then(m => m.DamsControlRunAddMeetingContentPageModule)
  },
  {
    path: 'dams-control-run-meeting-content-pic-change',
    loadChildren: () => import('./component/organisms/dams/dams-control-run-meeting-content-pic-change/dams-control-run-meeting-content-pic-change.module').then(m => m.DamsControlRunMeetingContentPicChangePageModule)
  },
  {
    path: 'dams-control-run-add-pcba',
    loadChildren: () => import('./component/organisms/dams/dams-control-run-add-pcba/dams-control-run-add-pcba.module').then(m => m.DamsControlRunAddPcbaPageModule)
  },
  {
    path: 'dams-control-run-add-fatp',
    loadChildren: () => import('./component/organisms/dams/dams-control-run-add-fatp/dams-control-run-add-fatp.module').then(m => m.DamsControlRunAddFatpPageModule)
  },
  {
    path: 'dams-control-run-add-hold-stage',
    loadChildren: () => import('./component/organisms/dams/dams-control-run-add-hold-stage/dams-control-run-add-hold-stage.module').then(m => m.DamsControlRunAddHoldStagePageModule)
  },
  {
    path: 'dams-control-run-select-line',
    loadChildren: () => import('./component/organisms/dams/dams-control-run-select-line/dams-control-run-select-line.module').then(m => m.DamsControlRunSelectLinePageModule)
  },
  {
    path: 'dams-control-run-select-stage',
    loadChildren: () => import('./component/organisms/dams/dams-control-run-select-stage/dams-control-run-select-stage.module').then(m => m.DamsControlRunSelectStagePageModule)
  }
  
  DamsControlRunAddFatpPage
  DamsControlRunAddHoldStagePage
  DamsControlRunAddMeetingContentPage
  DamsControlRunAddPcbaPage
  DamsControlRunMeetingContentPicChangePage
  DamsControlRunSelectLinePage
  DamsControlRunSelectStagePage
```



切入方式 Running change,immdeiate change.

- 会议主席显示更新按钮 loginrole = signer
- 会议主席显示 重新发起 在总览界面

###### 图片显示组件显示5张 测试

``` html
            <div>
                <ion-item lines="full" class="imageListPadding">
                    <ion-thumbnail class="imgThumbnail margin" slot="start">
                        <ion-img src="assets/icon/dams/icon-clock.svg"></ion-img>
                    </ion-thumbnail>
                    <ion-thumbnail class="imgThumbnail margin" slot="start">
                        <ion-img src="assets/icon/dams/icon-clock.svg"></ion-img>
                    </ion-thumbnail>
                    <ion-thumbnail class="imgThumbnail margin" slot="start">
                        <ion-img src="assets/icon/dams/icon-clock.svg"></ion-img>
                    </ion-thumbnail>
                    <ion-thumbnail class="imgThumbnail margin" slot="start">
                        <ion-img src="assets/icon/dams/icon-clock.svg"></ion-img>
                    </ion-thumbnail>
                    <ion-thumbnail class="imgThumbnail margin" slot="start">
                        <ion-img src="assets/icon/dams/icon-clock.svg"></ion-img>
                    </ion-thumbnail>
                    <ion-thumbnail class="imgThumbnail margin" slot="start">
                        <ion-img src="assets/icon/dams/icon-clock.svg"></ion-img>
                    </ion-thumbnail>
                    <ion-thumbnail class="imgThumbnail margin" slot="start">
                        <ion-icon class="addImg" src="assets/icon/dams/add-img.svg"></ion-icon>
                    </ion-thumbnail>
                </ion-item>
            </div>
```





採購

```javascript
const path = require('path');
const fs = require('fs');
const json = fs.readFileSync(path.join(__dirname, 'ionic.config.json'), { encoding: 'utf-8' });
const xml = fs.readFileSync(path.join(__dirname, 'config.xml'), { encoding: 'utf-8' });
const newVersionArray = new Date().toISOString().split('-');
newVersionArray.push(newVersionArray.pop().substring(0, 2));
newVersionArray.unshift(newVersionArray.shift().substring(2, 4));
const newVersion = newVersionArray.join('') + '01';
const jsonStr = json.replace(/(?<="android-versionCode": "|"ios-CFBundleVersion": ")\d{8,8}/g, newVersion);
const xmlStr = xml.replace(/(?<=android-versionCode="|ios-CFBundleVersion=")\d{8,8}/g, newVersion);
const oldVersion = /(?<="android-versionCode": "|"ios-CFBundleVersion": ")\d{8,8}/g.exec(json)[0];
console.log(newVersion, oldVersion.substring(0, oldVersion.length - 2));

if(oldVersion.substring(0, oldVersion.length - 2) === newVersion.substring(0, newVersion.length - 2)){
    
}
console.log(oldVersion);
// fs.writeFileSync(path.join(__dirname, 'ionic.config.json'), jsonStr, { encoding: 'utf-8' });
// fs.writeFileSync(path.join(__dirname, 'config.xml'), xmlStr, { encoding: 'utf-8' });
```



#### PLM系统reason of change 清单

>Customer Issue - Specification/Configuration Change
>
>Customer Issue - Special/Additional Requirement
>
>Design Issue - ME/Tooling Related
>
>Design Issue - EE Related
>
>Design Issue - SW/BIOS Related
>
>Design Issue - EMI, ESD, Thermal, Safety Related
>
>Material Issue - Vendor Change
>
>Material Issue - Component Version Change
>
>Material Issue - Vendor Manufacturing Site Change
>
>Material Issue - Alternative Part
>
>Material Issue - Shortage
>
>Operation Issue - Manufacturing Process Change
>
>Operation Issue - Manufacturing Site Change
>
>Operation Issue - BOM Structure Change
>
>Human Issue - Wrong Part/BOM
>
>ECN Addendum
>
>SW/FW Part - Create First Version/RN
>
>Contract Issue
>
>Special Verification Requirements
>
>可以選的就這些

#### 流程图

>https://modao.cc/flow/design/pbkrd85kagb2iasq
>
>![image-20210909172631614](C:\Users\wh2104220\Desktop\doc\Markdown\DAMS\DAMS項目.assets\image-20210909172631614.png)

![image-20210908135023152](C:\Users\wh2104220\Desktop\doc\Markdown\DAMS\DAMS項目.assets\image-20210908135023152.png)

#### 会议记录

- PCBA MO 和 FATP MO 是发起人和QA才会显示这个部分

#### 确认发起

- 转库单和退库单 由库房来填写

#### sprint 1

- subject 主旨

- step 通知项目

- step type  搜索 时 设为 ''

- 纬创人员维护api

- 工号和名称

- 通知模板

  ````html
  Purge NO: 21092800002</br>
          料號：432-00710-S$AE</br>
          發起人：張秀蕾</br>
          填單人：楊葉</br>
          原因：雷雕有色差，purge除6/19，6/23 ，7/11的1440pcs之外的所有D/C材料</br>
          廠商：Ta Yang Silicone Rubber Industrial Co.,</br>
          庫存分佈:</br><p style="font-weight: 400; padding-left: 30px;"></p> 
  大概会长这个样子
  ````

  > ![image-20211008095808516](C:\Users\wh2104220\Desktop\doc\Markdown\DAMS\DAMS項目.assets\image-20211008095808516-1633658445581.png)

#### sprint3

- 

## VSCODE插件

- CSScomb	css排序 布局=> 尺寸 => 界面=> 文字=> 交互

## Git

1. git commit后 撤销commit

   ```
   git reset --soft HEAD^ 撤销commit 到上一个版本
   git reset --soft HEAD~1 撤销commit 到上一个版本
   git reset --soft HEAD~1 撤销commit 到前两个版本
   --soft 改为 --hard  连带add也撤销(删除工作区的改动代码)
   git commit --amend 进入vi编辑器 修改注释
   ```

   

## Angular

#### Constructor

> - 如果当前@Input 接收的变量没有在本组件 初始化过 , 那么 在这个方法里面得到的是undefined.
> - 当这个组件class被new 的时候 调用,constructor立即执行, 此时只能拿到class里面的property;

#### ngOnChanges

> - 当有外部输入属性时 才会调用一次(在ngOnInit之前)

> - 组件输入输入属性(@Input)发生变化的时候

> - 当被绑定的@Input值发生变化时调用,  首次调用一定会发生在ngOnInit之前

> - default 默认模式下 当绑定的 引用属性 属性 props 发生变化时, 会调用Docheck 钩子函数
> - onpush 模式下 : 

#### ngOnInit

#### ngDoCheck

> 任何一个变更检测被侦测到就会执行(执行次数很频繁)

#### ngAfterViewInit

> - 组件视图渲染的时候

#### ngAfterViewChecked

> - 组件视图改变的时候
> - 

## RegExp

1. 锚点

   - ^ 字符串或行 的开头
   - $字符串或行的结尾
   - \b 单词的开头或结尾
   - \B 单词的非开头或非结尾

2. 标志

   - i 忽略大小写  ignore
   - g 全局  global
   - m 每一行, 多行.  加上这个可以让每一行都能拿到^ 或者 $  multi

3. 组和引用

   - () 组
   - \1 引用   /(\w)a\1/g
   - (?:) 无法引用的组

4. 字符类

   - [abc] 匹配abc中的其中一个
   - [^abc] 匹配除了abc中的一个
   - [a-z]匹配a-z之间包括az的一个字符串
   - . 匹配任意字符 (除开 换行符之外的任意字符)
   - \w 匹配 字母数字下划线
   - \W 相当于 ^\w 
   - \d 匹配数字  digital : 0-9的数字
   - \D 相当于 ^\d
   - \s 匹配空白符
   - \S 非空白符

5. 量词与分支

   > *0个或者多个
   >
   > +一个多这个多个
   >
   > ?存在或者不存在可选  也就是说1个或者0个
   >
   > {1,} 至少一个
   >
   > {1,10} 1到10个之间
   >
   > {10} 必须重复10次
   >
   > |或 

6. 零宽断言

   - (<=?x)y  匹配前面有x的y
   - y(?=x) 匹配后面有x的y 
   - 以上两者取非 就是 将 = 改为 !
   - (<=!x)y 匹配前面不是x的y
   - y(?!x)匹配后面不是x的y

7. 转义字符

   - \xnm 匹配16进制数
   - \f 匹配换页符
   - \n 匹配换行
   - \r 匹配回车符
   - \t 匹配水平制表 table?
   - \v 匹配垂直制表vertical?
   - \unnnn 匹配unicode

8. 方法

   - RegExp.prototype.test(); 返回true/false  /\d/.test(2)
   - RegExp.prototype.exec();

9. string 方法

   - string.match(reg); 匹配符合正则的字符串片段,不影响源字符串
   - string.split(reg);  字符串转数组
   - string.search(reg)
   - string.replace(reg,str);
   - 

   

## this

- `this`不是指向自身, 而是一个指针, 指向调用函数的对象.
- `调用栈` 为了到达当前执行位置所调用的所有函数 (栈结构 后进先出)

this的绑定规则:

1. `默认绑定`

   ```javascript
   function sayHi(){
       console.log('Hello,', this.name);
   }
   var name = 'YvetteLau';
   sayHi(); 
   // 1. 此时打印出 hello,YvetteLau 拿到的是全局对象window对象下面的name值 ('use strict' 严格模式下 this指向的是undefined)
   // 2. node环境下 this指向的是一个对象,参考 << 深入浅出nodejs>> , 这个对象提供了模块导入导出功能. 
   ```

   ```javascript
   <script>
       // 1. this默认绑定
       //      直接调用的时候函数this默认绑定到window对象上, 严格模式 this 指向undefined , nodejs环境this指向一个对象
       // 2. 函数可以认为是一个对象
       //      但是直接在函数体用 `this.prop` 要考虑this的绑定指向问题; 
       //      匿名函数可以用 `argument.callee.prop` 
       //      具名函数可以用 `FnName.prop`
       // 3. 使用词法作用域规避this问题 
       //      在函数体外(当前函数作用域外定义一个变量)
       var c = 0;
       function foo(num) {
           console.log("foo: " + num);
           // 记录 foo 被调用的次数
           console.log(this.count);//此时默认this默认绑定到window对象下面, window没有count这个属性, 所以返回undefined , this.count ++ => NaN
           arguments.callee.count++; // 此时的count就是当前函数对象下面的count
           //匿名函数可以使用argument.callee   具名函数可以直接使用函数名 比如 foo.count++;
           this.count++;
           c++;
           // this.play = function(num){
           //     console.log('paly',num);
           // }
       }
       foo.count = 0;
       var i;
       for (i = 0; i < 10; i++) {
           if (i > 5) {
               foo(i);
           }
       }
       // foo: 6 
       // foo: 7 
       // foo: 8 
       // foo: 9 
       // foo 被调用了多少次？
       console.log(foo.count,c); // 0 -- 什么？
   
       var foo1 = new foo(100); //构造调用的时候 函数体会自动执行一次, 如果构造函数返回一个对象, 那么new 出来的新对象的this 会绑定到构造函数返回的对象上
   
       // console.log('ts',foo1(11),typeof foo1);
       // foo1.play('test');
   </script>
   ```

   

2. 隐式绑定

   ```javascript
   function sayHi(){
       console.log('Hello,', this.name);
   }
   var person = {
       name: 'YvetteLau',
       sayHi: sayHi
   }
   var name = 'Wiliam';
   person.sayHi();
   // 1. 虽然sayHi 方法定义在 person对象外部, 但是在调用的时候 会隐式的将this 指针绑定到当前调用上下文对象上
   ```

   

3. 硬绑定

   > - fn.call(target,any[]);
   > - fn.apply(target,[params]);
   > - fn = fn.bind(target,any[])    返回一个 this绑定target的 方法

4. new 绑定

5. 隐式绑定丢失

   > 回调函数导致的绑定丢失问题  有一个赋值的过程 导致绑定丢失

   ```javascript
   function sayHi(){
       console.log('Hello,', this.name);
   }
   var person1 = {
       name: 'YvetteLau',
       sayHi: function(){
           setTimeout(function(){
               console.log('Hello,',this.name);
           })
       }
   }
   var person2 = {
       name: 'Christina',
       sayHi: sayHi
   }
   var name='Wiliam';
   person1.sayHi();  //Hello, Wiliam
   setTimeout(person2.sayHi,100);  //Hello, Wiliam
   setTimeout(function(){
       person2.sayHi();  //Hello, Christina
   },200);
   
   
   
   ```

   

6. 调用栈和调用位置

   ```javascript
   function baz() { 
    // 当前调用栈是：baz 
    // 因此，当前调用位置是全局作用域
    console.log( "baz" ); 
    bar(); // <-- bar 的调用位置
   } 
   function bar() { 
   
    // 当前调用栈是 baz -> bar 
    // 因此，当前调用位置在 baz 中
    console.log( "bar" ); 
    foo(); // <-- foo 的调用位置
   } 
   function foo() { 
    // 当前调用栈是 baz -> bar -> foo 
    // 因此，当前调用位置在 bar 中
    console.log( "foo" ); 
   } 
   baz(); // <-- baz 的调用位置
   ```


## map && weakmap

> https://mp.weixin.qq.com/s/q2pq4JoYt21qX8N3TRKy_w

## RXJS

#### pipe 、map

```` typescript
const a = of([1, 2, 3]);//产生一个Observable 可观察对象

const b = map((data: number[]) => {//接收的是of里面的数组
      for( let i = 0; i < data.length; i++){
        data[i] = data[i] + 1;
      }
      console.log('data: ' + data);
      return data;
    } );

    const c = a.pipe(b);
    c.subscribe((data) => console.log('Fairy:' + data));

````

#### tap

​	不改变数据流, 只是对数据流做观测

## Angular Test

![image-20220217144214203](C:\Users\wh2104220\Desktop\doc\Markdown\DAMS\DAMS項目.assets\image-20220217144214203.png)

#### jasmine

1. `describe `和 `it`

````javascript
describe("A suite", function() {
  it("contains spec with an expectation", function() {
    expect(true).toBe(true);
  });
});
````

````javascript
describe("A suite is just a function", function() {
  var a;// 在describe 区域中声明的变量可以再任何it中使用
	// 在beforeEach , afterEach , beforeAll,afterAll 中都可以用
  it("and so is a spec", function() {
    a = true;

    expect(a).toBe(true);
  });
});
````

2. matcher列表 

   > [Namespace: matchers (jasmine.github.io)
   >
   > [](https://jasmine.github.io/api/edge/matchers.html)

3. 自定义matcher

> [Custom_matcher (jasmine.github.io)](https://jasmine.github.io/tutorials/custom_matcher.html)

4. beforeEach(function(){}); 每个spec之前执行

5. beforeAfter(function(){});每个spec之后执行

6. beforeAll() afterAll() 在所有的spec之前 或之后 只执行一次

7. this 关键字

   > 每一个spec 的 beforeEach / afterEach/ it 都有一个this 指向同一个空对象, 可以用来共享数据

   ````javascript
   describe("A spec", function() {
     beforeEach(function() {
       this.foo = 0; 
     });
   
     it("can use the `this` to share state", function() {
       expect(this.foo).toEqual(0);// this.foo 和 beforeEach 中的this.foo是同一个对象下的属性
       this.bar = "test pollution?";
     });
   
     it("prevents test pollution by having an empty `this` created for the next spec", function() {
       expect(this.foo).toEqual(0);
       expect(this.bar).toBe(undefined);
     });
   });
   ````

   

8. fail(string | Error project);

   > 可以使spec报错

9. describe 中可以嵌套describe

```javascript
describe("A spec", function() {
  var foo;

  beforeEach(function() {
    foo = 0;
    foo += 1;
  });

  afterEach(function() {
    foo = 0;
  });

  it("is just a function, so it can contain any code", function() {
    expect(foo).toEqual(1);
  });

  it("can have more than one expectation", function() {
    expect(foo).toEqual(1);
    expect(true).toEqual(true);
  });
	// 嵌套的描述
  describe("nested inside a second describe", function() {
    var bar;

    beforeEach(function() {
      bar = 1;
    });

    it("can reference both scopes as needed", function() {
      expect(foo).toEqual(bar);
    });
  });
});
```

10. xdescribe, xit 执行过程会被跳过
11. pending 表示当前测试用例处于暂停状态, 忽略执行结果
12. spies 模拟函数 ,追踪函数的调用,以及参数; 只能存在于describe 和it 中, 每个spec执行完都会被移除.
13. spics有特殊的[matcher ]([Namespace: matchers (jasmine.github.io)](https://jasmine.github.io/api/edge/matchers.html)), 还可以自定义[custom matcher]([Custom_matcher (jasmine.github.io)](https://jasmine.github.io/tutorials/custom_matcher.html))

````javascript
describe("A spy", function() {
  var foo, bar = null;

  beforeEach(function() {
    foo = {
      setBar: function(value) {
        bar = value;
      }
    };

//You can define what the spy will do when invoked with and.

    spyOn(foo, 'setBar');// 监视foo 对象的setbar方法

    foo.setBar(123);
    foo.setBar(456, 'another param');
  });

//The toHaveBeenCalled matcher will pass if the spy was called.

  it("tracks that the spy was called", function() {
    expect(foo.setBar).toHaveBeenCalled();// 调用过
  });

//The toHaveBeenCalledTimes matcher will pass if the spy was called the specified number of times.

  it("tracks that the spy was called x times", function() {
    expect(foo.setBar).toHaveBeenCalledTimes(2);//调用两次
  });

//The toHaveBeenCalledWith matcher will return true if the argument list matches any of the recorded calls to the spy.

  it("tracks all the arguments of its calls", function() {
    expect(foo.setBar).toHaveBeenCalledWith(123);//调用函数的参数为123
    expect(foo.setBar).toHaveBeenCalledWith(456, 'another param');
  });

  it("stops all execution on a function", function() {
    expect(bar).toBeNull();
  });

//You get all of the data that a spy tracks about its calls with calls

  it("tracks if it was called at all", function() {
    foo.setBar();

    expect(foo.setBar.calls.any()).toEqual(true);
  });
});
````

14. spies 可以用calls 属性来 获取所有的调用数据[calls]([Namespace: calls (jasmine.github.io)](https://jasmine.github.io/api/edge/Spy_calls.html))
15. spyOn(obj,obj.func) 监视对象的一个方法
16. spyOnProperty() 监听一个属性而不是方法
17. jasmine.createSpy()  生成一个间谍方法

- jasmine.createSpy().and.returnValue('value you expect'); 让间谍方法返回你想要的返回值

- jasmine.createSpy().and.callFake(func); 可以模拟整个方法,所以返回值也是这个被模拟的方法的返回值.

  ```javascript
  describe("Testing Bird with fake getSound() method", function() {
  						    it('calls the fake getSound() method created by createSpy()', function() {
  						        var b = new Bird();
  						        b.getSound = jasmine.createSpy().and.callFake(function(){
  						          return 'Hoot, Hoot!';
  						        });
  						        console.log(b.getSound());
  						        expect(b.getSound()).toEqual('Hoot, Hoot!');
  						    });
  						});
  ```

  

```javascript
describe("A spy, when created manually", function() {
  var whatAmI;

  beforeEach(function() {
      // 生成一个间谍方法 参数是一个标识, 如果报错 会用这个标识
    whatAmI = jasmine.createSpy('whatAmI');
  // 调用 这个间谍方法, 里面是是方法的参数
    whatAmI("I", "am", "a", "spy");
  });

  it("tracks that the spy was called", function() {
    expect(whatAmI).toHaveBeenCalled();
  });
});
```

17. jasmine.createObjSpy() 创建一个模拟对象, 他的属性和方法 都是间谍
18. jasmine.any();  不平等matcher

```javascript
  describe("jasmine.any", function() {
    it("matches any value", function() {
        // 构造函数匹配或者类匹配
      expect({}).toEqual(jasmine.any(Object));
      expect(12).toEqual(jasmine.any(Number));
    });

    describe("when used with a spy", function() {
      it("is useful for comparing arguments", function() {
        var foo = jasmine.createSpy('foo');
        foo(12, function() {
          return true;
        });

        expect(foo).toHaveBeenCalledWith(jasmine.any(Number), jasmine.any(Function));
      });
    });
  });
```

19. jasmine.anything() , 只要值不是null,undefined 就返回true,当参数可以被忽略时很有用
20. jasmine.objectContaining({key:value}); 当目标包含对应的键值对时,
21. jasmine.arrayContaining([v1,v2,v3]); 当目标数组包含对应的值
22. jasmine.stringMatching(string/regxp); 目标字符串包含对应的字符串或者能够匹配上对应的正则表达式
23. asymmetricMatch() 自定义非对称匹配 接收一个方法,参数是实际值, 返回值是用来期望的值
24. jasmine.clock().install

```javascript
describe("Manually ticking the Jasmine Clock", function() {
  var timerCallback;
¶
It is installed with a call to jasmine.clock().install in a spec or suite that needs to manipulate time.

  beforeEach(function() {
    timerCallback = jasmine.createSpy("timerCallback");
    jasmine.clock().install();
  });
¶
Be sure to uninstall the clock after you are done to restore the original functions.

  afterEach(function() {
    jasmine.clock().uninstall();
  });
¶
Mocking the JavaScript Timeout Functions
You can make setTimeout or setInterval synchronous executing the registered functions only once the clock is ticked forward in time.

To execute registered functions, move time forward via the jasmine.clock().tick function, which takes a number of milliseconds.

  it("causes a timeout to be called synchronously", function() {
    setTimeout(function() {
      timerCallback();
    }, 100);

    expect(timerCallback).not.toHaveBeenCalled();

    jasmine.clock().tick(101);

    expect(timerCallback).toHaveBeenCalled();
  });

  it("causes an interval to be called synchronously", function() {
    setInterval(function() {
      timerCallback();
    }, 100);

    expect(timerCallback).not.toHaveBeenCalled();

    jasmine.clock().tick(101);
    expect(timerCallback.calls.count()).toEqual(1);

    jasmine.clock().tick(50);
    expect(timerCallback.calls.count()).toEqual(1);

    jasmine.clock().tick(50);
    expect(timerCallback.calls.count()).toEqual(2);
  });
```

25. jasmine.clock().mockDate(DateObj); // 模拟一个日期

    ```javascript
      describe("Mocking the Date object", function(){
        it("mocks the Date object and sets it to a given time", function() {
          var baseTime = new Date(2013, 9, 23);
    ¶
    If you do not provide a base time to mockDate it will use the current date.
    
          jasmine.clock().mockDate(baseTime);
    
          jasmine.clock().tick(50);
          expect(new Date().getTime()).toEqual(baseTime.getTime() + 50);
        });
      });
    });
    ```



#### 组件测试场景

1. 注意结构型指令 ngfor 等, 可能导致拿不到dom元素

#### 测试@Output

> ```
>   it('should tabProject', () => {
>     spyOn(component, 'tabProject');
>     const btn = el.querySelector('ion-tab-button');
>     btn.click();
>     expect(component.tabProject).toHaveBeenCalled();
>   });
>   // 不需要关心tabProject里面的业务 , 这是另一个组件的事情
>   
> ```
>
> ![image-20220325130735538](E:\desktop\gitee\triennium\DAMS項目.assets\image-20220325130735538.png)
>
> ![image-20220325130849089](E:\desktop\gitee\triennium\DAMS項目.assets\image-20220325130849089.png)

```typescript
let el = fixture.nativeElement;
// 原生DOM元素
- 通过 querySelector('');方法 查找子元素
let dl = fixture.debugElement; 
//由angular 包装工的元素, 提供query 查询组件,指令,triggerEventHandler 触发DOM事件


let component: BannerComponent;
let fixture: ComponentFixture<BannerComponent>;
let h1: HTMLElement;

beforeEach(() => {
  TestBed.configureTestingModule({
    declarations: [ BannerComponent ],
  });
  fixture = TestBed.createComponent(BannerComponent);// 这里不会绑定数据
  component = fixture.componentInstance; // BannerComponent test instance
  h1 = fixture.nativeElement.querySelector('h1');
});

it('should display original title', () => {
  expect(h1.textContent).toContain(component.title);
  // el.textContent 属性相当于 ele.innertext
  // toContain() // 是一个matcher 期望包括
});
```

1. createComponent() 不绑定数据
2. fixture.detectChanges() 主动执行变更检测, 执行数据绑定
3. ComponentFixtureAutoDetect 自动变更检测

```typescript
      providers: [{ provide: ComponentFixtureAutoDetect, useValue: true }],
```

​	4.dispatch() 改变输入

## [Angular DI]([Angular依赖注入介绍 - 简书 (jianshu.com)](https://www.jianshu.com/p/4b10948d456c))

> 理解: 
>
> 在angular 的DI框架中 他会维护很多 实例对象 (Dependency), 你要获取实例对象就需要使用标识(Token)获取.
>
> 1. Dependency 依赖, 被注入对象实例
> 2. Token 令牌, 令牌对应依赖, 
> 3. Injector 注入器,负责创建和维护服务对象的实例, 并且向组件中注入
> 4. Provider 提供者,配置注入器的对象,指定创建服务实例对象的服务类(Dependency)和获取实例对象的标识(Token)

​	@Injectable 装饰器可以将一个类定义为一个服务, angular可以把服务作为依赖注入到组建中. 同样 @Injectable 装饰器也可以表示一个组件或类有一个依赖;

- 注入器 angular启动时会自动创建
- 注入器会创建依赖, 维护一个容器来管理依赖, 尽可能复用
- 提供者 是一个对象, 告诉注入器应该如何获取或创建依赖(依赖可以是服务, 函数, 或者值)

```typescript
@Injectable({
    provideIn:'root'; //整个应用可以直接注入当前服务
	//如果不给定 提供者, 那就在使用之前需要在 @NgModule(),
    //或者 @Component() 装饰器中 指定provider 属性
})
```

#### Component 组件级注入器

- viewProviders/providers 可以设置当前组件可注入以及子组件可注入 还是 只允许当前组建注入, 子组件不允许注入

````typescript

@Component({
    selector: 'app-ngmodule-providers',
    templateUrl: './ngmodule-providers.component.html',
    styleUrls: ['./ngmodule-providers.component.less'],
    providers: [ComponentInjectService],   // providers提供的服务在当前组件和子组件都可以使用
    // viewProviders: [ComponentInjectService], // viewProviders提供的服务在当前组件使用
})
````

#### Provider 提供者

- 最简单的提供者 providers:[serviceClass], 直接写服务类

#### Provider Token

- Token用来表示依赖对象, token值可以是type,injectionToken,OpaqueToken类的实例或字符串.通常不建议使用字符串, 容易命名冲突

  > 可以简单认为 token 是依赖对象的key, 通过这个key找到依赖对象

  ````typescript
  export declare type Provider = TypeProvider | ValueProvider | ClassProvider | ConstructorProvider | ExistingProvider | FactoryProvider | any[];
  ````

  

#### 依赖对象的创建方式 

- 如下几种Provider:

  - Type

    - ```
      @NgModule({
        ...
        providers: [NgmoduleProvidersService], // NgmoduleProvidersService是我们定义的服务，TypeProvider方式
      })
      ```

    - TypeProvider用于告诉Injector(注入器)，使用给定的Type创建对象，并且Token也是给定的Type。这也是我们用的最多的一种方式。比如如下。就是采用的TypeProvider方式。

  - Value

    - ```
      export interface ValueSansProvider {
        /**
         * 需要注入的值
         */
        useValue: any;
      }
      
      export interface ValueProvider extends ValueSansProvider {
        /**
         * 用于设置与依赖对象关联的Token值，Token值可能是Type、InjectionToken、OpaqueToken的实例或字符串
         */
        provide: any;
        /**
         * 用于标识是否multiple providers，若是multiple类型，则返回与Token关联的依赖对象列表
         * 简单来说如果multi是true的话，通过provide(Token)获取的依赖对象是一个列表。
         * 同一个Token可以注入多个服务
         */
        multi?: boolean;
      }
      ```

    - ```
      export const TOKEN_MODULE_CONFIG = new InjectionToken<Config>('TOKEN_MODULE_CONFIG');
      
      /**
       * Config是我们自定义的一个配置对象
       */
      const config = new Config();
      config.version = '1.1.2';
      
      @NgModule({
          ...
          providers: [
              {provide: TOKEN_MODULE_CONFIG, useValue: config},
          ],
          ...
      })
      export class ValueProviderModule {
      }
      ```

    -   ValueProvider用于告诉Injector(注入器)，useValue指定的值(可以是具体的对象也可以是string ,number等等之类的值)就是Token依赖的对象。

  - Class

    -   ClassProvider用于告诉Injector(注入器)，useClass指定的Type创建的对应对象就是Token对应的对象。

    - ```
      export interface ClassSansProvider {
          /**
           * token生成对象对应的class.
           * 用该class生成服务对象
           */
          useClass: Type<any>;
      }
      
      export interface ClassProvider extends ClassSansProvider {
          /**
           * 用于设置与依赖对象关联的Token值，Token值可能是Type、InjectionToken、OpaqueToken的实例或字符串
           */
          provide: any;
          /**
           * 用于标识是否multiple providers，若是multiple类型，则返回与Token关联的依赖对象列表
           * 简单来说如果multi是true的话，通过provide(Token)获取的依赖对象是一个列表。
           * 同一个Token可以注入多个服务
           */
          multi?: boolean;
      }
      ```

    - ```
      export const TOKEN_MODULE_CLASS_PROVIDER = new InjectionToken<any>('TOKEN_MODULE_CLASS_PROVIDER');
      // ModuleClassProviderService类是我们依赖对象
      
      @NgModule({
          ...
          providers: [
              {
                  provide: TOKEN_MODULE_CLASS_PROVIDER, useClass: ModuleClassProviderService
              }
          ],
          ...
      })
      export class ClassProviderModule {
      }
      ```

    - 

  - Constructor

  - Existing

  - Factory

  - any[]

## JSON 序列化

- 对象中的属性值如果是undefined, Symbol, function 都会被序列化过滤

## gulp

1. process.chdir('目标路径'); 改变当前目录
2. exec("echo 'hello'"); 执行shell脚本
3. src('');  以流(stream)的形式读取文件
4. pipe(); 处理流数据
5. dest('将文件生成到指定的路径',{overwrite:true}); 是否覆盖写入 是
6.  series(task1,task2...); 任务顺序执行
7. parallel(task1,task2...);任务同时执行

## CSS

- 文件目录

  - index 将下面的css文件引入在这里管理
  - atom 原子类 

  ```css
  // 原子类
  .align-left {
      text-align: left;
  }
  
  .align-center {
      text-align: center;
  }
  
  .align-right {
      text-align: right;
  }
  
  .float-l {
      float: left;
  }
  
  .float-r {
      float: right;
  }
  ```

  

  - variable
  - layout
  - mixin
  - global
  - themes
  - preload 预加载
  
  > 1. text-transform:uppercase / lowercase / capitalize
  > 2. 

## typescript

#### Utility Type

1. `Record<keys, type>`

```typescript
interface CatInfo {
  age: number;
  breed: string;
}
 
type CatName = "miffy" | "boris" | "mordred";
 
const cats: Record<CatName, CatInfo> = {
  miffy: { age: 10, breed: "Persian" },
  boris: { age: 5, breed: "Maine Coon" },
  mordred: { age: 16, breed: "British Shorthair" },
};
type test1 = Record<string, { age: 10 }>;
type test2 = Record<number, { age: 10 }>;
type test3 = Record<symbol, { age: 10 }>;
type test4 = Record<1 | 2 | 'name' | symbol, { age: 10 }>;
```

2. `Pick<type, keys>`

```
interface Todo {
  title: string;
  description: string;
  completed: boolean;
}
 
type TodoPreview = Pick<Todo, "title" | "completed">;
// keys 是 keyof type 的一部分;
// 从type 选取一部分指定的属性
```

## web worker

1. 不会被主线程打断, 及时主线程卡死
2. 受同源策略影响, 同原网页才能访问
3. 不能操作,访问dom
4. 不能使用全局交互方法alert confirm
5. 不能读取本地文件
6. worker 线程和主线程不共享作用域和资源
7. 两种worker
   - Dedicated web worker : 专用线程, 只能在一个网页使用这线程
   - Shared web worker; 共享线程,可以再多个同源网页共享,可以跨页面通信

## Http缓存

1. 强缓存
   - expires : 秒数
   - cache-control(相对expires优先级更高) : 日期
2. 协商缓存
   - last-modified, if-modified-since
   - Etag, if-none-match(优先级更高)

## 页面生命周期

1. `DOMContentLoaded` 浏览器完全加载了HTML文件, 并且构建了DOM树,但是像img的图片或者css样式文件 可能还没有加载完成

   ```  
   <script>
     document.addEventListener("DOMContentLoaded", () => {
       alert("DOM ready!");
     });
   </script>
   
   <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js"></script>
   
   <script>
     alert("Library loaded, inline script executed");
   </script>
   ```

   - script标签会阻塞`DOMContentLoaded` 事件

     例外:

     - 具有async 属性的script标签
     - 使用documen.createElement('script'); 动态生成的并且添加到网页的脚本也不会阻塞

2. `load` 浏览器加载完成了HTML, 还加载了所有外部资源 (图片,css等);

3. `beforeunload/unload` 用户正在离开页面时

## 事件

- 冒泡
- event.target 事件触发者
- event.stopPropagation(); 停止事件冒泡, 但是如果该元素绑定了其他事件, 其他事件还是会继续执行,并且冒泡
- event.stopImmediatePropagation(); 停止冒泡, 并且阻止当前元素上的其他处理程序运行
- targetELe.addEventListener('click',method,true/false 默认是fasle,true代表事件捕获  )
- 如果 目标元素同事监听 冒泡和捕获, 那么 两种事件都会在元素上执行一次
- event.eventPhase 返回 1 2 3;
  - 1 捕获阶段
  - 2 事件目标元素阶段
  - 3 冒泡阶段
- 同一元素  多个监听器 按顺序执行

## 事件委托

## 浏览器的默认行为

- on<event>  可以使用return false;
- addEventListener 使用 event.preventDefault();
- event.defaultPrevented; 这个属性表示是否被阻止默认事件
- `addEventListener` 的 `passive: true` 选项告诉浏览器该行为不会被阻止。这对于某些移动端的事件（像 `touchstart` 和 `touchmove`）很有用，用以告诉浏览器在滚动之前不应等待所有处理程序完成。

## 资源加载

- onload  ----成功加载
- onerror ----加载失败

```
let script = document.createElement('script');

// 可以从任意域（domain），加载任意脚本
script.src = "https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js"
document.head.append(script);
// onerror 同样的用法
script.onload = function() {
  // 该脚本创建了一个变量 "_"
  alert( _.VERSION ); // 显示库的版本
};
```

- 但是有一些注意事项：

  - 大多数资源在被添加到文档中后，便开始加载。但是 `<img>` 是个例外。它要等到获得 src `(*)` 后才开始加载。
  - 对于 `<iframe>` 来说，iframe 加载完成时会触发 `iframe.onload` 事件，无论是成功加载还是出现 error。

  这是出于历史原因。

## mutation observer

DOM变化观察

## Nginx

#### 典型配置

````
    server {
    	listen       80;       # 配置监听的端口
    	server_name  localhost;    # 配置的域名
    	
    	location / {
    		root   /usr/share/nginx/html;  # 网站根目录
    		index  index.html index.htm;   # 默认首页文件
    		deny 172.168.22.11;   # 禁止访问的ip地址，可以为all
    		allow 172.168.33.44； # 允许访问的ip地址，可以为all
    	}
    	
    	error_page 500 502 503 504 /50x.html;  # 默认50x对应的访问页面
    	error_page 400 404 error.html;   # 同上
    }

````



#### http core

## YAML

> 注意事项 :
>
> 1. 大小写敏感
> 2. 缩进表示层级
> 3. 不允许使用tab, 只能用空格
> 4. 缩进的空格数目不重要, 只要相同的层级元素左侧对齐即可
> 5. 

## 模块化

#### commonjs

1. 每个模块内部 module对象代表当前模块
2. module对象的exports属性代表暴露出去的对外接口
3. 加载某个模块其实是加载模块的module.exports;  require()方法用来加载模块
4. 每个模块被加载时都会被执行一次, 加载后会被缓存, 多次require() 不会多次调用, 优先从缓存中调用

#### npm包

1. npmjs.org 在这里搜索包
2. registry.npmjs.org对外共享所有的包

#### 常用npm包

1. moment.js 日期格式化

#### npm包版本的语义化规范

1. 版本号以"点分十进制" 总共三位数字 例如: 2.24.0
   - 第一位 2 代表大版本
   - 第二位 24 代表功能版本
   - 第三位0 代表bug修复版本
   - 只要前面的版本更新了,那么后面的数字就要归零.
2. package.json中的main属性的作用: 当require('./path'); 导入一个文件夹路径的时候, 没有指定文件, node会查找对应文件加下面是否有package.json这个文件, 有的话 就会读取main 属性的 路径, 从而导入对应的模块.  如果main对应路径文件不存在则尝试加载index.js



#### npm login 登陆 

> 一定要切换到官方源

#### npm publish

> 发布包到npm上

#### npm unpublish 包名 --force 

> 删除已经发布过的包



## ionic 

#### 插件

1. @ionic-native/status-bar 状态栏颜色
2. x 兼容性问题 @awesome-cordova-plugins/app-center-crashes 自动捕捉用户行为,操作系统等用户信息

## 并发模型

#### 浏览器线程

- 渲染引擎线程
- javascript引擎线程  和 渲染引擎线程互斥
- 定时触发器线程
- 浏览器事件触发线程 => 处理DOM事件
- 异步http请求线程

#### 任务队列

1. 所有同步异步任务按照编译原理在主线程执行, 形成一个执行上下文栈,

#### 事件循环运行过程

- script标签是一个全局任务, 属于宏任务(里面的代码就是我们写的同步代码);
- script标签执行完之后先执行所有的微任务(promise,mutastionObserver,postMessage...);
- 微任务执行完之后再执行下一个宏任务